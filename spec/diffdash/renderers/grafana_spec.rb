# frozen_string_literal: true

RSpec.describe Diffdash::Renderers::Grafana do
  describe "#render" do
    context "with empty signals" do
      subject(:renderer) do
        described_class.new(
          signals: [],
          title: "Empty Dashboard",
          folder_id: nil
        )
      end

      it "returns valid Grafana JSON structure" do
        result = renderer.render

        expect(result).to have_key(:dashboard)
        expect(result).to have_key(:folderId)
        expect(result).to have_key(:overwrite)
        expect(result).to have_key(:message)
      end

      it "includes empty dashboard panel" do
        result = renderer.render
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(1)
        expect(panels.first[:type]).to eq("text")
        expect(panels.first[:title]).to eq("No Signals Detected")
      end

      it "sets overwrite to true" do
        result = renderer.render
        expect(result[:overwrite]).to be true
      end

      it "includes auto-generated message" do
        result = renderer.render
        expect(result[:message]).to eq("Auto-generated by diffdash gem")
      end
    end

    context "with log signals" do
      let(:log_signal) do
        Diffdash::Signal::Log.new(
          name: "payment_processed",
          source_file: "/app/services/payment.rb",
          defining_class: "PaymentService",
          inheritance_depth: 0,
          metadata: { level: "info", line: 42 }
        )
      end

      subject(:renderer) do
        described_class.new(
          signals: [log_signal],
          title: "Test Dashboard",
          folder_id: 123
        )
      end

      it "creates log panel" do
        result = renderer.render
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(1)
        expect(panels.first[:type]).to eq("logs")
        expect(panels.first[:title]).to include("payment_processed")
      end

      it "includes folder ID" do
        result = renderer.render
        expect(result[:folderId]).to eq(123)
      end

      it "sets dashboard title" do
        result = renderer.render
        expect(result[:dashboard][:title]).to eq("Test Dashboard")
      end

      it "generates deterministic UID" do
        result1 = renderer.render
        result2 = renderer.render

        expect(result1[:dashboard][:uid]).to eq(result2[:dashboard][:uid])
      end

      it "includes Loki datasource in log panel" do
        result = renderer.render
        panel = result[:dashboard][:panels].first

        expect(panel[:targets].first[:datasource][:type]).to eq("loki")
      end
    end

    context "with counter signals" do
      let(:counter_signal) do
        Diffdash::Signal::Counter.new(
          name: "requests_total",
          source_file: "/app/controllers/api.rb",
          defining_class: "ApiController",
          inheritance_depth: 0
        )
      end

      subject(:renderer) do
        described_class.new(
          signals: [counter_signal],
          title: "Metrics Dashboard",
          folder_id: nil
        )
      end

      it "creates counter panel" do
        result = renderer.render
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(1)
        expect(panels.first[:type]).to eq("timeseries")
        expect(panels.first[:title]).to include("Counter:")
        expect(panels.first[:title]).to include("requests_total")
      end

      it "includes Prometheus datasource" do
        result = renderer.render
        panel = result[:dashboard][:panels].first

        expect(panel[:targets].first[:datasource][:type]).to eq("prometheus")
      end

      it "uses rate() for counter queries" do
        result = renderer.render
        panel = result[:dashboard][:panels].first

        expect(panel[:targets].first[:expr]).to include("rate(")
      end
    end

    context "with gauge signals" do
      let(:gauge_signal) do
        Diffdash::Signal::Gauge.new(
          name: "queue_size",
          source_file: "/app/workers/queue.rb",
          defining_class: "QueueWorker",
          inheritance_depth: 0
        )
      end

      subject(:renderer) do
        described_class.new(
          signals: [gauge_signal],
          title: "Gauge Dashboard",
          folder_id: nil
        )
      end

      it "creates gauge panel" do
        result = renderer.render
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(1)
        expect(panels.first[:title]).to include("Gauge:")
        expect(panels.first[:title]).to include("queue_size")
      end

      it "does not use rate() for gauge queries" do
        result = renderer.render
        panel = result[:dashboard][:panels].first

        expect(panel[:targets].first[:expr]).not_to include("rate(")
      end
    end

    context "with histogram signals" do
      let(:histogram_signal) do
        Diffdash::Signal::Histogram.new(
          name: "request.duration",
          source_file: "/app/middleware/timing.rb",
          defining_class: "TimingMiddleware",
          inheritance_depth: 0
        )
      end

      subject(:renderer) do
        described_class.new(
          signals: [histogram_signal],
          title: "Histogram Dashboard",
          folder_id: nil
        )
      end

      it "creates three panels for histogram (p50, p95, p99)" do
        result = renderer.render
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(3)
        expect(panels[0][:title]).to include("p50")
        expect(panels[1][:title]).to include("p95")
        expect(panels[2][:title]).to include("p99")
      end

      it "uses histogram_quantile in queries" do
        result = renderer.render
        panels = result[:dashboard][:panels]

        panels.each do |panel|
          expect(panel[:targets].first[:expr]).to include("histogram_quantile")
        end
      end
    end

    context "with mixed signals" do
      let(:log_signal) do
        Diffdash::Signal::Log.new(
          name: "event",
          source_file: "/app/test.rb",
          defining_class: "Test",
          inheritance_depth: 0
        )
      end

      let(:counter_signal) do
        Diffdash::Signal::Counter.new(
          name: "counter",
          source_file: "/app/test.rb",
          defining_class: "Test",
          inheritance_depth: 0
        )
      end

      subject(:renderer) do
        described_class.new(
          signals: [log_signal, counter_signal],
          title: "Mixed Dashboard",
          folder_id: nil
        )
      end

      it "creates panels for both signal types" do
        result = renderer.render
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(2)
        expect(panels[0][:type]).to eq("logs")
        expect(panels[1][:type]).to eq("timeseries")
      end

      it "positions log panels before metric panels" do
        result = renderer.render
        panels = result[:dashboard][:panels]

        log_panel_y = panels[0][:gridPos][:y]
        metric_panel_y = panels[1][:gridPos][:y]

        expect(log_panel_y).to be < metric_panel_y
      end
    end

    context "dashboard metadata" do
      subject(:renderer) do
        described_class.new(
          signals: [],
          title: "Test Dashboard",
          folder_id: nil
        )
      end

      it "includes Grafana tags" do
        result = renderer.render
        tags = result[:dashboard][:tags]

        expect(tags).to include("auto-pr")
        expect(tags).to include("diffdash")
      end

      it "includes templating variables" do
        result = renderer.render
        variables = result[:dashboard][:templating][:list]

        variable_names = variables.map { |v| v[:name] }
        expect(variable_names).to include("datasource")
        expect(variable_names).to include("datasource_loki")
        expect(variable_names).to include("env")
        expect(variable_names).to include("app")
      end

      it "includes deployment annotations" do
        result = renderer.render
        annotations = result[:dashboard][:annotations][:list]

        expect(annotations.size).to eq(1)
        expect(annotations.first[:name]).to eq("Deployments")
      end

      it "sets schema version" do
        result = renderer.render
        expect(result[:dashboard][:schemaVersion]).to eq(39)
      end

      it "sets refresh interval" do
        result = renderer.render
        expect(result[:dashboard][:refresh]).to eq("30s")
      end
    end
  end
end
