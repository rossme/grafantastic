# frozen_string_literal: true

RSpec.describe Diffdash::Outputs::Grafana do
  describe "#render" do
    context "with empty signals" do
      subject(:renderer) { described_class.new(title: "Empty Dashboard", folder_id: nil) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          metadata: {
            time_range: { from: "now-30m", to: "now" },
            change_set: { branch_name: "feature/pr-123" }
          }
        )
      end

      it "returns valid Grafana JSON structure" do
        result = renderer.render(bundle)

        expect(result).to have_key(:dashboard)
        expect(result).to have_key(:folderId)
        expect(result).to have_key(:overwrite)
        expect(result).to have_key(:message)
      end

      it "includes empty dashboard panel" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(1)
        expect(panels.first[:type]).to eq("text")
        expect(panels.first[:title]).to eq("No Signals Detected")
      end

      it "sets overwrite to true" do
        result = renderer.render(bundle)
        expect(result[:overwrite]).to be true
      end

      it "includes auto-generated message" do
        result = renderer.render(bundle)
        expect(result[:message]).to eq("Auto-generated by diffdash gem")
      end
    end

    context "with log signals" do
      let(:log_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :logs,
          name: "payment_processed",
          time_range: { from: "now-30m", to: "now" },
          source_file: "/app/services/payment.rb",
          defining_class: "PaymentService",
          metadata: { level: "info", line: 42 }
        )
      end

      subject(:renderer) { described_class.new(title: "Test Dashboard", folder_id: 123) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metrics: [],
          traces: [],
          metadata: { time_range: { from: "now-30m", to: "now" } }
        )
      end

      it "creates log panel" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]
        log_panels = panels.select { |p| p[:type] == "logs" }

        expect(log_panels.size).to eq(1)
        expect(log_panels.first[:title]).to include("payment_processed")
      end

      it "includes getting started guidance panel" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]
        text_panels = panels.select { |p| p[:type] == "text" }

        expect(text_panels.size).to eq(1)
        expect(text_panels.first[:options][:content]).to include("**Diffdash**")
      end

      it "includes folder ID" do
        result = renderer.render(bundle)
        expect(result[:folderId]).to eq(123)
      end

      it "sets dashboard title" do
        result = renderer.render(bundle)
        expect(result[:dashboard][:title]).to eq("Test Dashboard")
      end

      it "generates deterministic UID" do
        result1 = renderer.render(bundle)
        result2 = renderer.render(bundle)

        expect(result1[:dashboard][:uid]).to eq(result2[:dashboard][:uid])
      end

      it "includes Loki datasource in log panel" do
        result = renderer.render(bundle)
        log_panel = result[:dashboard][:panels].find { |p| p[:type] == "logs" }

        expect(log_panel[:targets].first[:datasource][:type]).to eq("loki")
      end

      it "uses exact literal matching for log messages" do
        log_signal = Diffdash::Engine::SignalQuery.new(
          type: :logs,
          name: "Hello from Grape API!",
          time_range: { from: "now-30m", to: "now" },
          source_file: "/app/services/payment.rb",
          defining_class: "PaymentService",
          metadata: { level: "info", line: 42 }
        )
        bundle = Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metrics: [],
          traces: [],
          metadata: { time_range: { from: "now-30m", to: "now" } }
        )
        renderer = described_class.new(title: "Test Dashboard", folder_id: 123)

        result = renderer.render(bundle)
        log_panel = result[:dashboard][:panels].find { |p| p[:type] == "logs" }
        expr = log_panel[:targets].first[:expr]

        expect(expr).to include("|= \"Hello from Grape API!\"")
      end
    end

    context "with counter signals" do
      let(:counter_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :metrics,
          name: "requests_total",
          time_range: { from: "now-30m", to: "now" },
          source_file: "/app/controllers/api.rb",
          defining_class: "ApiController",
          metadata: { metric_type: :counter }
        )
      end

      subject(:renderer) { described_class.new(title: "Metrics Dashboard", folder_id: nil) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          logs: [],
          metrics: [counter_signal],
          traces: [],
          metadata: { time_range: { from: "now-30m", to: "now" } }
        )
      end

      it "creates counter panel" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]
        counter_panels = panels.select { |p| p[:type] == "timeseries" }

        expect(counter_panels.size).to eq(1)
        expect(counter_panels.first[:title]).to include("Counter:")
        expect(counter_panels.first[:title]).to include("requests_total")
      end

      it "includes Prometheus datasource" do
        result = renderer.render(bundle)
        counter_panel = result[:dashboard][:panels].find { |p| p[:type] == "timeseries" }

        expect(counter_panel[:targets].first[:datasource][:type]).to eq("prometheus")
      end

      it "uses rate() for counter queries" do
        result = renderer.render(bundle)
        counter_panel = result[:dashboard][:panels].find { |p| p[:type] == "timeseries" }

        expect(counter_panel[:targets].first[:expr]).to include("rate(")
      end
    end

    context "with gauge signals" do
      let(:gauge_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :metrics,
          name: "queue_size",
          time_range: { from: "now-30m", to: "now" },
          source_file: "/app/workers/queue.rb",
          defining_class: "QueueWorker",
          metadata: { metric_type: :gauge }
        )
      end

      subject(:renderer) { described_class.new(title: "Gauge Dashboard", folder_id: nil) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          logs: [],
          metrics: [gauge_signal],
          traces: [],
          metadata: { time_range: { from: "now-30m", to: "now" } }
        )
      end

      it "creates gauge panel" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]
        gauge_panels = panels.select { |p| p[:type] == "timeseries" }

        expect(gauge_panels.size).to eq(1)
        expect(gauge_panels.first[:title]).to include("Gauge:")
        expect(gauge_panels.first[:title]).to include("queue_size")
      end

      it "does not use rate() for gauge queries" do
        result = renderer.render(bundle)
        gauge_panel = result[:dashboard][:panels].find { |p| p[:type] == "timeseries" }

        expect(gauge_panel[:targets].first[:expr]).not_to include("rate(")
      end
    end

    context "with histogram signals" do
      let(:histogram_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :metrics,
          name: "request.duration",
          time_range: { from: "now-30m", to: "now" },
          source_file: "/app/middleware/timing.rb",
          defining_class: "TimingMiddleware",
          metadata: { metric_type: :histogram }
        )
      end

      subject(:renderer) { described_class.new(title: "Histogram Dashboard", folder_id: nil) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          logs: [],
          metrics: [histogram_signal],
          traces: [],
          metadata: { time_range: { from: "now-30m", to: "now" } }
        )
      end

      it "creates three panels for histogram (p50, p95, p99)" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]
        histogram_panels = panels.select { |p| p[:type] == "timeseries" }

        expect(histogram_panels.size).to eq(3)
        expect(histogram_panels[0][:title]).to include("p50")
        expect(histogram_panels[1][:title]).to include("p95")
        expect(histogram_panels[2][:title]).to include("p99")
      end

      it "uses histogram_quantile in queries" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]
        histogram_panels = panels.select { |p| p[:type] == "timeseries" }

        histogram_panels.each do |panel|
          expect(panel[:targets].first[:expr]).to include("histogram_quantile")
        end
      end
    end

    context "with mixed signals" do
      let(:log_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :logs,
          name: "event",
          time_range: { from: "now-30m", to: "now" },
          source_file: "/app/test.rb",
          defining_class: "Test"
        )
      end

      let(:counter_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :metrics,
          name: "counter",
          time_range: { from: "now-30m", to: "now" },
          source_file: "/app/test.rb",
          defining_class: "Test",
          metadata: { metric_type: :counter }
        )
      end

      subject(:renderer) { described_class.new(title: "Mixed Dashboard", folder_id: nil) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metrics: [counter_signal],
          traces: [],
          metadata: { time_range: { from: "now-30m", to: "now" } }
        )
      end

      it "creates panels for both signal types" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]
        log_panels = panels.select { |p| p[:type] == "logs" }
        metric_panels = panels.select { |p| p[:type] == "timeseries" }

        expect(log_panels.size).to eq(1)
        expect(metric_panels.size).to eq(1)
      end

      it "positions log panels before metric panels" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]

        log_panel = panels.find { |p| p[:type] == "logs" }
        metric_panel = panels.find { |p| p[:type] == "timeseries" }

        expect(log_panel[:gridPos][:y]).to be < metric_panel[:gridPos][:y]
      end
    end

    context "dashboard metadata" do
      subject(:renderer) { described_class.new(title: "Test Dashboard", folder_id: nil) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          metadata: {
            time_range: { from: "now-30m", to: "now" },
            change_set: { branch_name: "feature/pr-123" }
          }
        )
      end

      it "includes Grafana tags" do
        result = renderer.render(bundle)
        tags = result[:dashboard][:tags]

        expect(tags).to include("auto-pr")
        expect(tags).to include("diffdash")
      end

      it "includes templating variables" do
        result = renderer.render(bundle)
        variables = result[:dashboard][:templating][:list]

        variable_names = variables.map { |v| v[:name] }
        expect(variable_names).to include("datasource")
        expect(variable_names).to include("datasource_loki")
        expect(variable_names).to include("env")
        expect(variable_names).to include("app")
      end

      it "includes deployment annotations" do
        result = renderer.render(bundle)
        annotations = result[:dashboard][:annotations][:list]

        expect(annotations.size).to eq(2)
        base = annotations.first
        pr = annotations.last

        expect(base[:name]).to eq("Deployments")
        expect(base[:datasource]).to eq(type: "prometheus", uid: "${datasource}")
        expect(base[:enable]).to be true
        expect(base[:expr]).to eq("changes(deploy_timestamp[5m]) > 0")
        expect(base[:tagKeys]).to eq("app,env")
        expect(base[:titleFormat]).to eq("Deploy")

        expect(pr[:name]).to eq("PR Deployments")
        expect(pr[:datasource]).to eq(type: "prometheus", uid: "${datasource}")
        expect(pr[:enable]).to be true
        expect(pr[:expr]).to eq("changes(deploy_timestamp{branch=\"feature/pr-123\"}[5m]) > 0")
        expect(pr[:tagKeys]).to eq("app,env,branch")
        expect(pr[:titleFormat]).to eq("PR Deploy")
      end

      it "sets schema version" do
        result = renderer.render(bundle)
        expect(result[:dashboard][:schemaVersion]).to eq(39)
      end

      it "sets refresh interval" do
        result = renderer.render(bundle)
        expect(result[:dashboard][:refresh]).to eq("30s")
      end
    end

    context "with default_env option" do
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          metadata: {
            time_range: { from: "now-30m", to: "now" },
            change_set: { branch_name: "feature/test" }
          }
        )
      end

      it "defaults env to production" do
        renderer = described_class.new(title: "Test", folder_id: nil)
        result = renderer.render(bundle)

        env_var = result[:dashboard][:templating][:list].find { |v| v[:name] == "env" }
        expect(env_var[:current]).to eq({ text: "production", value: "production" })
      end

      it "allows overriding default env to staging" do
        renderer = described_class.new(title: "Test", folder_id: nil, default_env: "staging")
        result = renderer.render(bundle)

        env_var = result[:dashboard][:templating][:list].find { |v| v[:name] == "env" }
        expect(env_var[:current]).to eq({ text: "staging", value: "staging" })
      end

      it "allows overriding default env to development" do
        renderer = described_class.new(title: "Test", folder_id: nil, default_env: "development")
        result = renderer.render(bundle)

        env_var = result[:dashboard][:templating][:list].find { |v| v[:name] == "env" }
        expect(env_var[:current]).to eq({ text: "development", value: "development" })
      end
    end

    context "Getting Started panel with PR links" do
      let(:log_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :logs,
          name: "test_log",
          time_range: { from: "now-30m", to: "now" },
          source_file: "/app/test.rb",
          defining_class: "TestClass",
          metadata: { level: "info", line: 1 }
        )
      end

      subject(:renderer) { described_class.new(title: "Test Dashboard", folder_id: nil) }

      before do
        # Mock git remote URL
        allow_any_instance_of(Object).to receive(:`).with("git config --get remote.origin.url")
          .and_return("git@github.com:rossme/diffdash-test-app.git\n")
      end

      it "includes PR link with number when GITHUB_PR_NUMBER is set" do
        ENV["GITHUB_PR_NUMBER"] = "42"
        
        bundle = Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metadata: {
            time_range: { from: "now-30m", to: "now" },
            change_set: { branch_name: "feature/test" }
          }
        )

        result = renderer.render(bundle)
        getting_started = result[:dashboard][:panels].find { |p| p[:type] == "text" }
        
        expect(getting_started[:options][:content]).to eq("**Diffdash** — [View PR](https://github.com/rossme/diffdash-test-app/pull/42)")
        
        ENV.delete("GITHUB_PR_NUMBER")
      end

      it "extracts PR number from GITHUB_REF" do
        ENV["GITHUB_REF"] = "refs/pull/123/merge"
        
        bundle = Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metadata: {
            time_range: { from: "now-30m", to: "now" },
            change_set: { branch_name: "feature/test" }
          }
        )

        result = renderer.render(bundle)
        getting_started = result[:dashboard][:panels].find { |p| p[:type] == "text" }
        
        expect(getting_started[:options][:content]).to eq("**Diffdash** — [View PR](https://github.com/rossme/diffdash-test-app/pull/123)")
        
        ENV.delete("GITHUB_REF")
      end

      it "links to /pulls when in CI without PR number" do
        ENV["CI"] = "true"
        
        bundle = Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metadata: {
            time_range: { from: "now-30m", to: "now" },
            change_set: { branch_name: "feature/test" }
          }
        )

        result = renderer.render(bundle)
        getting_started = result[:dashboard][:panels].find { |p| p[:type] == "text" }
        
        expect(getting_started[:options][:content]).to eq("**Diffdash** — [View PR](https://github.com/rossme/diffdash-test-app/pulls)")
        
        ENV.delete("CI")
      end

      it "links to branch tree when running locally" do
        bundle = Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metadata: {
            time_range: { from: "now-30m", to: "now" },
            change_set: { branch_name: "feature/test-branch" }
          }
        )

        result = renderer.render(bundle)
        getting_started = result[:dashboard][:panels].find { |p| p[:type] == "text" }
        
        expect(getting_started[:options][:content]).to eq("**Diffdash** — [View PR](https://github.com/rossme/diffdash-test-app/tree/feature/test-branch)")
      end

      it "handles HTTPS git URLs" do
        allow_any_instance_of(Object).to receive(:`).with("git config --get remote.origin.url")
          .and_return("https://github.com/rossme/diffdash-test-app.git\n")
        
        ENV["GITHUB_PR_NUMBER"] = "99"
        
        bundle = Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metadata: {
            time_range: { from: "now-30m", to: "now" },
            change_set: { branch_name: "feature/test" }
          }
        )

        result = renderer.render(bundle)
        getting_started = result[:dashboard][:panels].find { |p| p[:type] == "text" }
        
        expect(getting_started[:options][:content]).to eq("**Diffdash** — [View PR](https://github.com/rossme/diffdash-test-app/pull/99)")
        
        ENV.delete("GITHUB_PR_NUMBER")
      end

      it "does not include PR link when git remote is unavailable" do
        allow_any_instance_of(Object).to receive(:`).with("git config --get remote.origin.url")
          .and_return("")
        
        bundle = Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metadata: {
            time_range: { from: "now-30m", to: "now" },
            change_set: { branch_name: "feature/test" }
          }
        )

        result = renderer.render(bundle)
        getting_started = result[:dashboard][:panels].find { |p| p[:type] == "text" }
        
        expect(getting_started[:options][:content]).to eq("**Diffdash**")
      end
    end
  end
end
