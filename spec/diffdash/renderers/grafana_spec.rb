# frozen_string_literal: true

RSpec.describe Diffdash::Outputs::Grafana do
  describe "#render" do
    context "with empty signals" do
      subject(:renderer) { described_class.new(title: "Empty Dashboard", folder_id: nil) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          metadata: {
            time_range: { from: "now-1h", to: "now" },
            change_set: { branch_name: "feature/pr-123" }
          }
        )
      end

      it "returns valid Grafana JSON structure" do
        result = renderer.render(bundle)

        expect(result).to have_key(:dashboard)
        expect(result).to have_key(:folderId)
        expect(result).to have_key(:overwrite)
        expect(result).to have_key(:message)
      end

      it "includes empty dashboard panel" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(1)
        expect(panels.first[:type]).to eq("text")
        expect(panels.first[:title]).to eq("No Signals Detected")
      end

      it "sets overwrite to true" do
        result = renderer.render(bundle)
        expect(result[:overwrite]).to be true
      end

      it "includes auto-generated message" do
        result = renderer.render(bundle)
        expect(result[:message]).to eq("Auto-generated by diffdash gem")
      end
    end

    context "with log signals" do
      let(:log_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :logs,
          name: "payment_processed",
          time_range: { from: "now-1h", to: "now" },
          source_file: "/app/services/payment.rb",
          defining_class: "PaymentService",
          metadata: { level: "info", line: 42 }
        )
      end

      subject(:renderer) { described_class.new(title: "Test Dashboard", folder_id: 123) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metrics: [],
          traces: [],
          metadata: { time_range: { from: "now-1h", to: "now" } }
        )
      end

      it "creates log panel" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(1)
        expect(panels.first[:type]).to eq("logs")
        expect(panels.first[:title]).to include("payment_processed")
      end

      it "includes folder ID" do
        result = renderer.render(bundle)
        expect(result[:folderId]).to eq(123)
      end

      it "sets dashboard title" do
        result = renderer.render(bundle)
        expect(result[:dashboard][:title]).to eq("Test Dashboard")
      end

      it "generates deterministic UID" do
        result1 = renderer.render(bundle)
        result2 = renderer.render(bundle)

        expect(result1[:dashboard][:uid]).to eq(result2[:dashboard][:uid])
      end

      it "includes Loki datasource in log panel" do
        result = renderer.render(bundle)
        panel = result[:dashboard][:panels].first

        expect(panel[:targets].first[:datasource][:type]).to eq("loki")
      end

      it "uses exact literal matching for log messages" do
        log_signal = Diffdash::Engine::SignalQuery.new(
          type: :logs,
          name: "Hello from Grape API!",
          time_range: { from: "now-1h", to: "now" },
          source_file: "/app/services/payment.rb",
          defining_class: "PaymentService",
          metadata: { level: "info", line: 42 }
        )
        bundle = Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metrics: [],
          traces: [],
          metadata: { time_range: { from: "now-1h", to: "now" } }
        )
        renderer = described_class.new(title: "Test Dashboard", folder_id: 123)

        result = renderer.render(bundle)
        expr = result[:dashboard][:panels].first[:targets].first[:expr]

        expect(expr).to include("|= \"Hello from Grape API!\"")
      end
    end

    context "with counter signals" do
      let(:counter_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :metrics,
          name: "requests_total",
          time_range: { from: "now-1h", to: "now" },
          source_file: "/app/controllers/api.rb",
          defining_class: "ApiController",
          metadata: { metric_type: :counter }
        )
      end

      subject(:renderer) { described_class.new(title: "Metrics Dashboard", folder_id: nil) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          logs: [],
          metrics: [counter_signal],
          traces: [],
          metadata: { time_range: { from: "now-1h", to: "now" } }
        )
      end

      it "creates counter panel" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(1)
        expect(panels.first[:type]).to eq("timeseries")
        expect(panels.first[:title]).to include("Counter:")
        expect(panels.first[:title]).to include("requests_total")
      end

      it "includes Prometheus datasource" do
        result = renderer.render(bundle)
        panel = result[:dashboard][:panels].first

        expect(panel[:targets].first[:datasource][:type]).to eq("prometheus")
      end

      it "uses rate() for counter queries" do
        result = renderer.render(bundle)
        panel = result[:dashboard][:panels].first

        expect(panel[:targets].first[:expr]).to include("rate(")
      end
    end

    context "with gauge signals" do
      let(:gauge_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :metrics,
          name: "queue_size",
          time_range: { from: "now-1h", to: "now" },
          source_file: "/app/workers/queue.rb",
          defining_class: "QueueWorker",
          metadata: { metric_type: :gauge }
        )
      end

      subject(:renderer) { described_class.new(title: "Gauge Dashboard", folder_id: nil) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          logs: [],
          metrics: [gauge_signal],
          traces: [],
          metadata: { time_range: { from: "now-1h", to: "now" } }
        )
      end

      it "creates gauge panel" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(1)
        expect(panels.first[:title]).to include("Gauge:")
        expect(panels.first[:title]).to include("queue_size")
      end

      it "does not use rate() for gauge queries" do
        result = renderer.render(bundle)
        panel = result[:dashboard][:panels].first

        expect(panel[:targets].first[:expr]).not_to include("rate(")
      end
    end

    context "with histogram signals" do
      let(:histogram_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :metrics,
          name: "request.duration",
          time_range: { from: "now-1h", to: "now" },
          source_file: "/app/middleware/timing.rb",
          defining_class: "TimingMiddleware",
          metadata: { metric_type: :histogram }
        )
      end

      subject(:renderer) { described_class.new(title: "Histogram Dashboard", folder_id: nil) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          logs: [],
          metrics: [histogram_signal],
          traces: [],
          metadata: { time_range: { from: "now-1h", to: "now" } }
        )
      end

      it "creates three panels for histogram (p50, p95, p99)" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(3)
        expect(panels[0][:title]).to include("p50")
        expect(panels[1][:title]).to include("p95")
        expect(panels[2][:title]).to include("p99")
      end

      it "uses histogram_quantile in queries" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]

        panels.each do |panel|
          expect(panel[:targets].first[:expr]).to include("histogram_quantile")
        end
      end
    end

    context "with mixed signals" do
      let(:log_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :logs,
          name: "event",
          time_range: { from: "now-1h", to: "now" },
          source_file: "/app/test.rb",
          defining_class: "Test"
        )
      end

      let(:counter_signal) do
        Diffdash::Engine::SignalQuery.new(
          type: :metrics,
          name: "counter",
          time_range: { from: "now-1h", to: "now" },
          source_file: "/app/test.rb",
          defining_class: "Test",
          metadata: { metric_type: :counter }
        )
      end

      subject(:renderer) { described_class.new(title: "Mixed Dashboard", folder_id: nil) }
      let(:bundle) do
        Diffdash::Engine::SignalBundle.new(
          logs: [log_signal],
          metrics: [counter_signal],
          traces: [],
          metadata: { time_range: { from: "now-1h", to: "now" } }
        )
      end

      it "creates panels for both signal types" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]

        expect(panels.size).to eq(2)
        expect(panels[0][:type]).to eq("logs")
        expect(panels[1][:type]).to eq("timeseries")
      end

      it "positions log panels before metric panels" do
        result = renderer.render(bundle)
        panels = result[:dashboard][:panels]

        log_panel_y = panels[0][:gridPos][:y]
        metric_panel_y = panels[1][:gridPos][:y]

        expect(log_panel_y).to be < metric_panel_y
      end
    end

    context "dashboard metadata" do
      subject(:renderer) { described_class.new(title: "Test Dashboard", folder_id: nil) }
      let(:bundle) { Diffdash::Engine::SignalBundle.new(metadata: { time_range: { from: "now-1h", to: "now" } }) }

      it "includes Grafana tags" do
        result = renderer.render(bundle)
        tags = result[:dashboard][:tags]

        expect(tags).to include("auto-pr")
        expect(tags).to include("diffdash")
      end

      it "includes templating variables" do
        result = renderer.render(bundle)
        variables = result[:dashboard][:templating][:list]

        variable_names = variables.map { |v| v[:name] }
        expect(variable_names).to include("datasource")
        expect(variable_names).to include("datasource_loki")
        expect(variable_names).to include("env")
        expect(variable_names).to include("app")
      end

      it "includes deployment annotations" do
        result = renderer.render(bundle)
        annotations = result[:dashboard][:annotations][:list]

        expect(annotations.size).to eq(2)
        expect(annotations.first[:name]).to eq("Deployments")
        expect(annotations.last[:name]).to eq("PR Deployments")
        expect(annotations.last[:expr]).to eq("changes(deploy_timestamp{branch=\"feature/pr-123\"}[5m]) > 0")
      end

      it "sets schema version" do
        result = renderer.render(bundle)
        expect(result[:dashboard][:schemaVersion]).to eq(39)
      end

      it "sets refresh interval" do
        result = renderer.render(bundle)
        expect(result[:dashboard][:refresh]).to eq("30s")
      end
    end
  end
end
