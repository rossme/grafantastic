# frozen_string_literal: true

module Diffdash
  module Services
    # Posts comments to GitHub PRs with dashboard links and signal summaries
    class PrCommenter
      COMMENT_MARKER = '<!-- diffdash-dashboard -->'

      def initialize(verbose: false, default_env: 'production')
        @verbose = verbose
        @default_env = default_env
      end

      # Post or update a comment on the current PR with the dashboard link
      # @param dashboard_url [String] URL to the Grafana dashboard
      # @param signal_bundle [SignalBundle] Bundle containing detected signals
      # @return [Boolean] true if comment was posted, false otherwise
      def post(dashboard_url:, signal_bundle: nil)
        return false unless github_pr_context?
        return false unless gh_cli_available?

        pr_number = current_pr_number
        return false unless pr_number

        comment_body = build_comment(dashboard_url, signal_bundle)

        # Check if we already have a diffdash comment
        existing_comment_id = find_existing_comment(pr_number)

        if existing_comment_id
          update_comment(existing_comment_id, comment_body)
        else
          create_comment(pr_number, comment_body)
        end

        true
      rescue StandardError => e
        log_verbose("Failed to post PR comment: #{e.message}")
        false
      end

      private

      def github_pr_context?
        ENV['GITHUB_ACTIONS'] == 'true' && ENV['GITHUB_EVENT_NAME'] == 'pull_request'
      end

      def gh_cli_available?
        system('which gh > /dev/null 2>&1')
      end

      def current_pr_number
        # In GitHub Actions, we can get PR number from GITHUB_REF or GITHUB_EVENT_PATH
        if ENV['GITHUB_REF']&.match?(%r{refs/pull/(\d+)/merge})
          return ENV['GITHUB_REF'].match(%r{refs/pull/(\d+)/merge})[1]
        end

        # Fallback: try to get from gh cli
        result = `gh pr view --json number -q '.number' 2>/dev/null`.strip
        result.empty? ? nil : result
      end

      def find_existing_comment(pr_number)
        # List comments and find one with our marker
        result = `gh pr view #{pr_number} --json comments -q '.comments[] | select(.body | contains("#{COMMENT_MARKER}")) | .id' 2>/dev/null`.strip
        result.empty? ? nil : result.split("\n").first
      end

      def create_comment(pr_number, body)
        log_verbose("Creating PR comment on ##{pr_number}")
        system('gh', 'pr', 'comment', pr_number, '--body', body)
      end

      def update_comment(comment_id, body)
        log_verbose("Updating existing PR comment #{comment_id}")
        system('gh', 'api', '-X', 'PATCH', "/repos/{owner}/{repo}/issues/comments/#{comment_id}", '-f', "body=#{body}")
      end

      def build_comment(dashboard_url, signal_bundle)
        signals_section = build_signals_section(signal_bundle)

        <<~COMMENT
          #{COMMENT_MARKER}
          ## üìä Diffdash Dashboard

          #{signals_section}
          **[View Dashboard](#{dashboard_url})**

          üí° Dashboard defaults to **#{@default_env}** environment, showing last 30 minutes

          ---
          <sub>Auto-generated by [diffdash](https://github.com/rossme/diffdash) v#{VERSION}</sub>
        COMMENT
      end

      def build_signals_section(signal_bundle)
        return "A Grafana dashboard has been created for this PR's observability signals.\n\n" unless signal_bundle

        logs = signal_bundle.logs || []
        metrics = signal_bundle.metrics || []

        log_count = logs.size
        metric_count = metrics.size

        if log_count.zero? && metric_count.zero?
          return "A Grafana dashboard has been created for this PR's observability signals.\n\n"
        end

        parts = []
        parts << "**#{log_count} #{log_count == 1 ? 'log' : 'logs'}**" if log_count.positive?
        parts << "**#{metric_count} #{metric_count == 1 ? 'metric' : 'metrics'}**" if metric_count.positive?

        section = "Detected #{parts.join(' and ')} in your changes:\n\n"

        # Group logs by defining class
        if log_count.positive?
          section += "<details>\n<summary>üìù Logs</summary>\n\n"
          logs_by_class = logs.group_by(&:defining_class)
          logs_by_class.each do |klass, class_logs|
            log_names = class_logs.map { |l| "`#{truncate(l.name, 40)}`" }.join(', ')
            section += "- **#{klass}** ‚Üí #{log_names}\n"
          end
          section += "\n</details>\n\n"
        end

        # Group metrics by type
        if metric_count.positive?
          section += "<details>\n<summary>üìà Metrics</summary>\n\n"
          metrics.each do |m|
            type = m.metadata[:metric_type] || :counter
            section += "- `#{m.name}` (#{type})\n"
          end
          section += "\n</details>\n\n"
        end

        section
      end

      def truncate(str, length)
        str.to_s.length > length ? "#{str[0, length - 3]}..." : str.to_s
      end

      def log_verbose(message)
        warn "[diffdash] #{message}" if @verbose
      end
    end
  end
end
