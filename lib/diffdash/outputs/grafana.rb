# frozen_string_literal: true

module Diffdash
  module Outputs
    # Grafana output adapter.
    # Translates SignalQuery intent into Grafana dashboard JSON.
    class Grafana < Base
      def initialize(title:, folder_id:, dry_run: false, verbose: false, default_env: "production",
                     app_name: nil, pr_deploy_annotation_expr: nil)
        @title = title
        @folder_id = folder_id
        @dry_run = dry_run
        @verbose = verbose
        @default_env = default_env
        @app_name = app_name
        @pr_deploy_annotation_expr = pr_deploy_annotation_expr
      end

      # Render SignalBundle into Grafana dashboard payload
      # @return [Hash] Grafana dashboard upload payload
      def render(signal_bundle)
        {
          dashboard: build_dashboard(signal_bundle),
          folderId: @folder_id&.to_i,
          overwrite: true,
          message: "Auto-generated by diffdash gem"
        }
      end

      def upload(payload)
        return { payload: payload, url: nil } if @dry_run

        client = Clients::Grafana.new
        log_verbose("Validating Grafana connection...")
        client.health_check!
        log_verbose("Connected to Grafana at #{client.url}")

        result = client.upload(payload)
        { payload: payload, url: result[:url] }
      end

      private

      def build_dashboard(signal_bundle)
        {
          id: nil,
          uid: generate_uid,
          title: @title,
          tags: %w[auto-pr diffdash],
          timezone: "browser",
          schemaVersion: 39,
          version: 0,
          refresh: "30s",
          time: {
            from: signal_bundle.metadata.dig(:time_range, :from) || "now-30m",
            to: signal_bundle.metadata.dig(:time_range, :to) || "now"
          },
          templating: build_templating,
          panels: build_panels(signal_bundle),
          annotations: build_annotations(signal_bundle)
        }
      end

      def generate_uid
        # Deterministic UID based on title
        require "digest"
        Digest::SHA256.hexdigest(@title)[0, 12]
      end

      def build_templating
        {
          list: [
            datasource_variable("datasource", "prometheus"),
            datasource_variable("datasource_loki", "loki"),
            environment_variable,
            app_variable
          ]
        }
      end

      def datasource_variable(name, query)
        {
          name: name,
          type: "datasource",
          query: query,
          current: {},  # Let Grafana auto-select the first matching datasource
          options: [],
          includeAll: false,
          multi: false,
          refresh: 1,
          hide: 0,
          regex: query == "loki" ? "/^(?!.*alert).*/" : ""  # Exclude alert datasources for Loki
        }
      end

      def environment_variable
        {
          name: "env",
          type: "custom",
          query: "production,staging,development,local",
          current: { text: @default_env, value: @default_env },
          includeAll: false,
          multi: false
        }
      end

      def app_variable
        # Infer app name from Git repo or allow override
        default_app = infer_app_name
        
        {
          name: "app",
          type: "query",
          datasource: { type: "loki", uid: "${datasource_loki}" },
          query: "label_values({app!=\"\"}, app)",
          refresh: 1,
          includeAll: false,  # Disable "All" option to force specific app selection
          multi: false,
          current: {
            text: default_app,
            value: default_app
          },
          options: [],
          sort: 1
        }
      end

      def infer_app_name
        # Priority: Configured app_name > Git repo name > wildcard
        return @app_name if @app_name && !@app_name.empty?

        # Try to get repo name from git remote
        begin
          remote_url = `git config --get remote.origin.url`.strip
          if remote_url.match(%r{[:/]([^/]+?)(?:\.git)?$})
            return $1
          end
        rescue
          # Fall through if git command fails
        end

        "*" # Wildcard fallback
      end

      def build_annotations(signal_bundle)
        annotations = [deployment_annotation]
        pr_annotation = pr_deployment_annotation(signal_bundle)
        annotations << pr_annotation if pr_annotation

        { list: annotations }
      end

      def build_panels(signal_bundle)
        return [empty_dashboard_panel] if signal_bundle.empty?

        panels = []
        panel_id = 1
        current_y = 0

        # Add guidance panel at the top
        panels << getting_started_panel(panel_id, signal_bundle)
        panel_id += 1
        current_y = 3 # Guidance panel is 3 units tall

        logs = signal_bundle.logs
        metrics = signal_bundle.metrics

        # Add log panels (2 per row)
        logs.each_with_index do |signal, idx|
          grid_pos = { x: (idx % 2) * 12, y: current_y + (idx / 2) * 8, w: 12, h: 8 }
          panels << log_panel(signal, panel_id, grid_pos)
          panel_id += 1
        end

        current_y += ((logs.size + 1) / 2) * 8 if logs.any?

        # Add metric panels (3 per row)
        metrics.each_with_index do |signal, idx|
          grid_pos = { x: (idx % 3) * 8, y: current_y + (idx / 3) * 8, w: 8, h: 8 }

          case signal.metadata[:metric_type]
          when :histogram
            histogram_panels = histogram_panels(signal, panel_id, grid_pos)
            panels.concat(histogram_panels)
            panel_id += histogram_panels.size
          when :gauge
            panels << gauge_panel(signal, panel_id, grid_pos)
            panel_id += 1
          else
            # Counter and others
            panels << counter_panel(signal, panel_id, grid_pos)
            panel_id += 1
          end
        end

        panels
      end

      # Panel generation methods - pure Grafana JSON construction

      def log_panel(signal, panel_id, grid_pos)
        {
          id: panel_id,
          type: "logs",
          title: "Log: #{truncate(signal.name, 30)}",
          description: "Source: #{signal.defining_class} (#{relative_path(signal.source_file)})",
          gridPos: grid_pos,
          targets: [
            {
              datasource: { type: "loki", uid: "${datasource_loki}" },
              expr: build_log_query(signal),
              refId: "A"
            }
          ],
          options: {
            showTime: true,
            showLabels: true,
            showCommonLabels: false,
            wrapLogMessage: true,
            prettifyLogMessage: false,
            enableLogDetails: true,
            sortOrder: "Descending"
          }
        }
      end

      def counter_panel(signal, panel_id, grid_pos)
        {
          id: panel_id,
          type: "timeseries",
          title: "Counter: #{truncate(signal.name, 25)}",
          description: "Source: #{signal.defining_class}",
          gridPos: grid_pos,
          targets: [
            {
              datasource: { type: "prometheus", uid: "${datasource}" },
              expr: "sum(rate(#{sanitize_metric_name(signal.name)}[$__rate_interval]))",
              legendFormat: "",
              refId: "A"
            }
          ],
          fieldConfig: {
            defaults: {
              unit: "ops",
              custom: {
                drawStyle: "line",
                lineInterpolation: "smooth",
                fillOpacity: 10
              }
            }
          },
          options: {
            legend: { displayMode: "list", placement: "bottom" }
          }
        }
      end

      def gauge_panel(signal, panel_id, grid_pos)
        {
          id: panel_id,
          type: "timeseries",
          title: "Gauge: #{truncate(signal.name, 25)}",
          description: "Source: #{signal.defining_class}",
          gridPos: grid_pos,
          targets: [
            {
              datasource: { type: "prometheus", uid: "${datasource}" },
              expr: "#{sanitize_metric_name(signal.name)}{env=~\"$env\", app=~\"$app\"}",
              legendFormat: "{{instance}}",
              refId: "A"
            }
          ],
          fieldConfig: {
            defaults: {
              custom: {
                drawStyle: "line",
                lineInterpolation: "smooth",
                fillOpacity: 5
              }
            }
          }
        }
      end

      def histogram_panels(signal, start_panel_id, start_grid_pos)
        panels = []
        percentiles = [
          { p: "0.5", label: "p50" },
          { p: "0.95", label: "p95" },
          { p: "0.99", label: "p99" }
        ]

        percentiles.each_with_index do |pct, idx|
          grid_pos = {
            x: (start_grid_pos[:x] + (idx * 8)) % 24,
            y: start_grid_pos[:y] + ((start_grid_pos[:x] + (idx * 8)) / 24) * 8,
            w: 8,
            h: 8
          }

          panels << {
            id: start_panel_id + idx,
            type: "timeseries",
            title: "#{truncate(signal.name, 20)} (#{pct[:label]})",
            description: "Source: #{signal.defining_class}",
            gridPos: grid_pos,
            targets: [
              {
                datasource: { type: "prometheus", uid: "${datasource}" },
                expr: "histogram_quantile(#{pct[:p]}, sum(rate(#{sanitize_metric_name(signal.name)}_bucket[$__rate_interval])) by (le))",
                legendFormat: "#{pct[:label]}",
                refId: "A"
              }
            ],
            fieldConfig: {
              defaults: {
                unit: "s",
                custom: {
                  drawStyle: "line",
                  lineInterpolation: "smooth",
                  fillOpacity: 10
                }
              }
            }
          }
        end

        panels
      end

      def empty_dashboard_panel
        {
          id: 1,
          type: "text",
          title: "No Signals Detected",
          gridPos: { x: 0, y: 0, w: 24, h: 4 },
          options: {
            mode: "markdown",
            content: "# No observability signals detected in this PR.\n\n" \
                     "This dashboard was auto-generated but found no logs, metrics, or events " \
                     "in the changed Ruby files."
          }
        }
      end

      def getting_started_panel(panel_id, signal_bundle)
        log_count = signal_bundle.logs&.size || 0
        metric_count = signal_bundle.metrics&.size || 0
        pr_link = build_pr_link(signal_bundle)

        content = "**Detected #{log_count} log#{log_count == 1 ? '' : 's'} and #{metric_count} metric#{metric_count == 1 ? '' : 's'}** in your PR."
        content += " [View PR](#{pr_link})" if pr_link
        content += "\n\nNo data yet? **Deploy** this PR, **trigger** the code path, then **wait** ~30s and refresh."

        {
          id: panel_id,
          type: "text",
          title: "ðŸš€ Getting Started",
          gridPos: { x: 0, y: 0, w: 24, h: 3 },
          options: {
            mode: "markdown",
            content: content
          }
        }
      end

      def build_pr_link(signal_bundle)
        change_set = signal_bundle.metadata[:change_set]
        return nil unless change_set

        branch = change_set[:branch_name]
        return nil unless branch

        # Try to get repo URL from git remote
        begin
          remote_url = `git config --get remote.origin.url`.strip
          return nil if remote_url.empty?

          # Convert SSH or HTTPS git URL to GitHub web URL
          if remote_url.match(%r{github\.com[:/](.+?)(?:\.git)?$})
            repo_path = $1
            # If branch looks like a PR branch, link to pulls, otherwise link to branch
            if ENV["GITHUB_HEAD_REF"] || ENV["CI"]
              "https://github.com/#{repo_path}/pulls"
            else
              "https://github.com/#{repo_path}/tree/#{branch}"
            end
          end
        rescue
          nil
        end
      end

      # Helper methods for rendering

      def build_log_query(signal)
        # Keep templating filters wired to the dashboard variables.
        # Use exact literal matching for static log messages.
        event_filter = signal.name ? " |= \"#{escape_log_value(signal.name)}\"" : ""
        "{env=~\"$env\", app=~\"$app\"}#{event_filter}"
      end

      def escape_log_value(value)
        value.to_s.gsub("\\", "\\\\").gsub("\"", "\\\"")
      end

      def escape_promql_label(value)
        value.to_s.gsub("\\", "\\\\").gsub("\"", "\\\"")
      end

      def sanitize_metric_name(name)
        name.to_s.gsub(/[^a-zA-Z0-9_:]/, "_")
      end

      def truncate(str, length)
        str.to_s.length > length ? "#{str[0, length - 3]}..." : str.to_s
      end

      def relative_path(path)
        path.to_s.sub(%r{^.*/app/}, "app/").sub(%r{^.*/lib/}, "lib/")
      end

      def log_verbose(message)
        warn "[diffdash] #{message}" if @verbose
      end

      def deployment_annotation
        {
          name: "Deployments",
          datasource: { type: "prometheus", uid: "${datasource}" },
          enable: true,
          expr: "changes(deploy_timestamp[5m]) > 0",
          tagKeys: "app,env",
          titleFormat: "Deploy"
        }
      end

      def pr_deployment_annotation(signal_bundle)
        expr = pr_deployment_expr(signal_bundle)
        return nil if expr.nil? || expr.empty?

        {
          name: "PR Deployments",
          datasource: { type: "prometheus", uid: "${datasource}" },
          enable: true,
          expr: expr,
          tagKeys: "app,env,branch",
          titleFormat: "PR Deploy"
        }
      end

      def pr_deployment_expr(signal_bundle)
        override = @pr_deploy_annotation_expr.to_s.strip
        return override unless override.empty?

        branch = signal_bundle.metadata.dig(:change_set, :branch_name).to_s.strip
        return nil if branch.empty?

        "changes(deploy_timestamp{branch=\"#{escape_promql_label(branch)}\"}[5m]) > 0"
      end
    end
  end
end
