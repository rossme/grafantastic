# frozen_string_literal: true

module Diffdash
  module Outputs
    # Grafana output adapter.
    # Translates SignalQuery intent into Grafana dashboard JSON.
    class Grafana < Base
      def initialize(title:, folder_id:, dry_run: false, verbose: false)
        @title = title
        @folder_id = folder_id
        @dry_run = dry_run
        @verbose = verbose
      end

      # Render SignalBundle into Grafana dashboard payload
      # @return [Hash] Grafana dashboard upload payload
      def render(signal_bundle)
        {
          dashboard: build_dashboard(signal_bundle),
          folderId: @folder_id&.to_i,
          overwrite: true,
          message: "Auto-generated by diffdash gem"
        }
      end

      def upload(payload)
        return { payload: payload, url: nil } if @dry_run

        client = Clients::Grafana.new
        log_verbose("Validating Grafana connection...")
        client.health_check!
        log_verbose("Connected to Grafana at #{client.url}")

        result = client.upload(payload)
        { payload: payload, url: result[:url] }
      end

      private

      def build_dashboard(signal_bundle)
        {
          id: nil,
          uid: generate_uid,
          title: @title,
          tags: %w[auto-pr diffdash],
          timezone: "browser",
          schemaVersion: 39,
          version: 0,
          refresh: "30s",
          time: {
            from: signal_bundle.metadata.dig(:time_range, :from) || "now-1h",
            to: signal_bundle.metadata.dig(:time_range, :to) || "now"
          },
          templating: build_templating,
          panels: build_panels(signal_bundle),
          annotations: build_annotations
        }
      end

      def generate_uid
        # Deterministic UID based on title
        require "digest"
        Digest::SHA256.hexdigest(@title)[0, 12]
      end

      def build_templating
        {
          list: [
            datasource_variable("datasource", "prometheus"),
            datasource_variable("datasource_loki", "loki"),
            service_variable,
            environment_variable,
            app_variable
          ]
        }
      end

      def datasource_variable(name, query)
        {
          name: name,
          type: "datasource",
          query: query,
          current: {},
          hide: 0
        }
      end

      def service_variable
        {
          name: "service",
          type: "query",
          datasource: { type: "prometheus", uid: "${datasource}" },
          query: "label_values(up, service)",
          refresh: 2,
          includeAll: false,
          multi: false
        }
      end

      def environment_variable
        {
          name: "env",
          type: "custom",
          query: "production,staging,development,local",
          current: { text: "production", value: "production" },
          includeAll: false,
          multi: false
        }
      end

      def app_variable
        {
          name: "app",
          type: "query",
          datasource: { type: "loki", uid: "${datasource_loki}" },
          query: "label_values({app!=\"\"}, app)",
          refresh: 2,
          includeAll: false,
          multi: false
        }
      end

      def build_annotations
        {
          list: [
            {
              name: "Deployments",
              datasource: { type: "prometheus", uid: "${datasource}" },
              enable: true,
              expr: "changes(deploy_timestamp{service=\"$service\"}[5m]) > 0",
              tagKeys: "service",
              titleFormat: "Deploy"
            }
          ]
        }
      end

      def build_panels(signal_bundle)
        return [empty_dashboard_panel] if signal_bundle.empty?

        panels = []
        panel_id = 1
        current_y = 0

        logs = signal_bundle.logs
        metrics = signal_bundle.metrics

        # Add log panels (2 per row)
        logs.each_with_index do |signal, idx|
          grid_pos = { x: (idx % 2) * 12, y: current_y + (idx / 2) * 8, w: 12, h: 8 }
          panels << log_panel(signal, panel_id, grid_pos)
          panel_id += 1
        end

        current_y += ((logs.size + 1) / 2) * 8 if logs.any?

        # Add metric panels (3 per row)
        metrics.each_with_index do |signal, idx|
          grid_pos = { x: (idx % 3) * 8, y: current_y + (idx / 3) * 8, w: 8, h: 8 }

          case signal.metadata[:metric_type]
          when :histogram
            histogram_panels = histogram_panels(signal, panel_id, grid_pos)
            panels.concat(histogram_panels)
            panel_id += histogram_panels.size
          when :gauge
            panels << gauge_panel(signal, panel_id, grid_pos)
            panel_id += 1
          else
            # Counter and others
            panels << counter_panel(signal, panel_id, grid_pos)
            panel_id += 1
          end
        end

        panels
      end

      # Panel generation methods - pure Grafana JSON construction

      def log_panel(signal, panel_id, grid_pos)
        {
          id: panel_id,
          type: "logs",
          title: "Log: #{truncate(signal.name, 30)}",
          description: "Source: #{signal.defining_class} (#{relative_path(signal.source_file)})",
          gridPos: grid_pos,
          targets: [
            {
              datasource: { type: "loki", uid: "${datasource_loki}" },
              expr: build_log_query(signal),
              refId: "A"
            }
          ],
          options: {
            showTime: true,
            showLabels: true,
            showCommonLabels: false,
            wrapLogMessage: true,
            prettifyLogMessage: false,
            enableLogDetails: true,
            sortOrder: "Descending"
          }
        }
      end

      def counter_panel(signal, panel_id, grid_pos)
        {
          id: panel_id,
          type: "timeseries",
          title: "Counter: #{truncate(signal.name, 25)}",
          description: "Source: #{signal.defining_class}",
          gridPos: grid_pos,
          targets: [
            {
              datasource: { type: "prometheus", uid: "${datasource}" },
              expr: "sum(rate(#{sanitize_metric_name(signal.name)}[$__rate_interval])) by (service)",
              legendFormat: "{{service}}",
              refId: "A"
            }
          ],
          fieldConfig: {
            defaults: {
              unit: "ops",
              custom: {
                drawStyle: "line",
                lineInterpolation: "smooth",
                fillOpacity: 10
              }
            }
          },
          options: {
            legend: { displayMode: "list", placement: "bottom" }
          }
        }
      end

      def gauge_panel(signal, panel_id, grid_pos)
        {
          id: panel_id,
          type: "timeseries",
          title: "Gauge: #{truncate(signal.name, 25)}",
          description: "Source: #{signal.defining_class}",
          gridPos: grid_pos,
          targets: [
            {
              datasource: { type: "prometheus", uid: "${datasource}" },
              expr: "#{sanitize_metric_name(signal.name)}{service=\"$service\", env=\"$env\"}",
              legendFormat: "{{instance}}",
              refId: "A"
            }
          ],
          fieldConfig: {
            defaults: {
              custom: {
                drawStyle: "line",
                lineInterpolation: "smooth",
                fillOpacity: 5
              }
            }
          }
        }
      end

      def histogram_panels(signal, start_panel_id, start_grid_pos)
        panels = []
        percentiles = [
          { p: "0.5", label: "p50" },
          { p: "0.95", label: "p95" },
          { p: "0.99", label: "p99" }
        ]

        percentiles.each_with_index do |pct, idx|
          grid_pos = {
            x: (start_grid_pos[:x] + (idx * 8)) % 24,
            y: start_grid_pos[:y] + ((start_grid_pos[:x] + (idx * 8)) / 24) * 8,
            w: 8,
            h: 8
          }

          panels << {
            id: start_panel_id + idx,
            type: "timeseries",
            title: "#{truncate(signal.name, 20)} (#{pct[:label]})",
            description: "Source: #{signal.defining_class}",
            gridPos: grid_pos,
            targets: [
              {
                datasource: { type: "prometheus", uid: "${datasource}" },
                expr: "histogram_quantile(#{pct[:p]}, sum(rate(#{sanitize_metric_name(signal.name)}_bucket[$__rate_interval])) by (le, service))",
                legendFormat: "{{service}} #{pct[:label]}",
                refId: "A"
              }
            ],
            fieldConfig: {
              defaults: {
                unit: "s",
                custom: {
                  drawStyle: "line",
                  lineInterpolation: "smooth",
                  fillOpacity: 10
                }
              }
            }
          }
        end

        panels
      end

      def empty_dashboard_panel
        {
          id: 1,
          type: "text",
          title: "No Signals Detected",
          gridPos: { x: 0, y: 0, w: 24, h: 4 },
          options: {
            mode: "markdown",
            content: "# No observability signals detected in this PR.\n\n" \
                     "This dashboard was auto-generated but found no logs, metrics, or events " \
                     "in the changed Ruby files."
          }
        }
      end

      # Helper methods for rendering

      def build_log_query(signal)
        event_filter = signal.name ? " |= `#{signal.name}`" : ""
        # Keep templating filters wired to the dashboard variables.
        "{service=~\"$service\", env=~\"$env\", app=~\"$app\"}#{event_filter}"
      end

      def sanitize_metric_name(name)
        name.to_s.gsub(/[^a-zA-Z0-9_:]/, "_")
      end

      def truncate(str, length)
        str.to_s.length > length ? "#{str[0, length - 3]}..." : str.to_s
      end

      def relative_path(path)
        path.to_s.sub(%r{^.*/app/}, "app/").sub(%r{^.*/lib/}, "lib/")
      end

      def log_verbose(message)
        warn "[diffdash] #{message}" if @verbose
      end
    end
  end
end
