# frozen_string_literal: true

module Diffdash
  module Outputs
    # Datadog output adapter.
    # Translates SignalQuery intent into Datadog dashboard JSON.
    class Datadog < Base
      def initialize(title:, dry_run: false, verbose: false)
        @title = title
        @dry_run = dry_run
        @verbose = verbose
      end

      # Render SignalBundle into Datadog dashboard payload
      # @return [Hash] Datadog dashboard JSON
      def render(signal_bundle)
        {
          title: @title,
          description: 'Auto-generated by diffdash gem',
          widgets: build_widgets(signal_bundle),
          layout_type: 'ordered',
          is_read_only: false,
          notify_list: [],
          template_variables: build_template_variables,
          tags: %w[diffdash auto-pr]
        }
      end

      def upload(payload)
        return { payload: payload, url: nil } if @dry_run

        client = Clients::Datadog.new
        log_verbose('Validating Datadog connection...')
        client.health_check!
        log_verbose('Connected to Datadog')

        result = client.upload_dashboard(payload)
        { payload: payload, url: result[:url] }
      end

      private

      def build_widgets(signal_bundle)
        widgets = []

        # Log widgets
        signal_bundle.logs.each do |signal|
          widgets << log_widget(signal)
        end

        # Metric widgets
        signal_bundle.metrics.each do |signal|
          widgets << case signal.metadata[:metric_type]
                     when :counter
                       counter_widget(signal)
                     when :gauge
                       gauge_widget(signal)
                     when :histogram
                       histogram_widget(signal)
                     else
                       counter_widget(signal) # Default
                     end
        end

        widgets
      end

      def log_widget(signal)
        {
          definition: {
            type: 'log_stream',
            title: "Log: #{signal.name}",
            query: build_log_query(signal),
            columns: %w[host service],
            show_date_column: true,
            show_message_column: true,
            message_display: 'expanded-md'
          }
        }
      end

      def counter_widget(signal)
        {
          definition: {
            type: 'timeseries',
            title: "Counter: #{signal.name}",
            requests: [
              {
                q: "sum:#{sanitize_metric_name(signal.name)}{$env,$service}.as_rate()",
                display_type: 'line',
                style: {
                  palette: 'dog_classic',
                  line_type: 'solid',
                  line_width: 'normal'
                }
              }
            ],
            yaxis: {
              label: '',
              scale: 'linear',
              min: 'auto',
              max: 'auto'
            }
          }
        }
      end

      def gauge_widget(signal)
        {
          definition: {
            type: 'timeseries',
            title: "Gauge: #{signal.name}",
            requests: [
              {
                q: "avg:#{sanitize_metric_name(signal.name)}{$env,$service}",
                display_type: 'line'
              }
            ]
          }
        }
      end

      def histogram_widget(signal)
        {
          definition: {
            type: 'timeseries',
            title: "Histogram: #{signal.name}",
            requests: [
              {
                q: "avg:#{sanitize_metric_name(signal.name)}.95percentile{$env,$service}",
                display_type: 'line'
              },
              {
                q: "avg:#{sanitize_metric_name(signal.name)}.median{$env,$service}",
                display_type: 'line'
              }
            ]
          }
        }
      end

      def build_template_variables
        [
          {
            name: 'env',
            prefix: 'env',
            available_values: %w[production staging development],
            default: 'production'
          },
          {
            name: 'service',
            prefix: 'service',
            available_values: [],
            default: infer_service_name
          }
        ]
      end

      def build_log_query(signal)
        # Datadog log query syntax
        filters = ['env:$env', 'service:$service']
        filters << "\"#{signal.name}\"" if signal.name
        filters.join(' ')
      end

      def sanitize_metric_name(name)
        # Datadog metric naming: lowercase, dots for namespacing
        name.to_s.downcase.gsub(/[^a-z0-9._]/, '_')
      end

      def infer_service_name
        # Same logic as Grafana app inference
        return ENV['DIFFDASH_SERVICE_NAME'] if ENV['DIFFDASH_SERVICE_NAME']

        begin
          remote_url = `git config --get remote.origin.url`.strip
          return ::Regexp.last_match(1) if remote_url.match(%r{[:/]([^/]+?)(?:\.git)?$})
        rescue StandardError
          # Fall through
        end

        '*'
      end

      def log_verbose(message)
        warn "[diffdash] #{message}" if @verbose
      end
    end
  end
end
